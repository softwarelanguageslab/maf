; Changes:
; * removed: 1
; * added: 8
; * swaps: 0
; * negated predicates: 6
; * swapped branches: 6
; * calls to id fun: 13
(letrec ((map (lambda (f lst)
                (if (pair? lst)
                   (cons (f (car lst)) (map f (cdr lst)))
                   ())))
         (for-each (lambda (f lst)
                     (begin
                        (<change>
                           (if (pair? lst)
                              (cons (f (car lst)) (map f (cdr lst)))
                              ())
                           ())
                        (<change>
                           ()
                           cdr)
                        (void))))
         (string->list (lambda (s)
                         (letrec ((f (lambda (i)
                                       (if (< i (string-length s))
                                          (cons (string-ref s i) (f (+ i 1)))
                                          ()))))
                            (f 0))))
         (apply (lambda (f l)
                  (let ((len (length l)))
                     (<change>
                        (if (= len 0)
                           (f)
                           (if (= len 1)
                              (f (car l))
                              (if (= len 2)
                                 (f (car l) (cadr l))
                                 (if (= len 3)
                                    (f (car l) (cadr l) (caddr l))
                                    (if (= len 4)
                                       (f (car l) (cadr l) (caddr l) (cadddr l))
                                       #f)))))
                        ((lambda (x) x)
                           (if (= len 0)
                              (f)
                              (if (= len 1)
                                 (f (car l))
                                 (if (= len 2)
                                    (<change>
                                       (f (car l) (cadr l))
                                       (if (= len 3)
                                          (f (car l) (cadr l) (caddr l))
                                          (if (= len 4)
                                             (f (car l) (cadr l) (caddr l) (cadddr l))
                                             #f)))
                                    (<change>
                                       (if (= len 3)
                                          (f (car l) (cadr l) (caddr l))
                                          (if (= len 4)
                                             (f (car l) (cadr l) (caddr l) (cadddr l))
                                             #f))
                                       (f (car l) (cadr l)))))))))))
         (gensym-count 0)
         (gensym (lambda (name)
                   (begin
                      (set! gensym-count (+ gensym-count 1))
                      (string->symbol
                         (string-append (if (symbol? name) (symbol->string name) name) "$" (number->string gensym-count))))))
         (three-d-tagged-list? (lambda (tag lst)
                                 (if (pair? lst)
                                    (let ((__or_res (eq? (car lst) tag)))
                                       (if __or_res
                                          __or_res
                                          (if (procedure? (car lst))
                                             (equal? ((car lst)) (initial tag))
                                             #f)))
                                    #f)))
         (tagged-list? (lambda (tag lst)
                         (if (pair? lst) (eq? (car lst) tag) #f)))
         (singlet? (lambda (list)
                     (if (pair? list) (null? (cdr list)) #f)))
         (partition-k (lambda (pred list k)
                        (if (not (pair? list))
                           (k () ())
                           (partition-k
                              pred
                              (cdr list)
                              (lambda (trues falses)
                                 (if (pred (car list))
                                    (k (cons (car list) trues) falses)
                                    (k trues (cons (car list) falses))))))))
         (unzip-amap-k (lambda (amap k)
                         (if (not (pair? amap))
                            (k () ())
                            (unzip-amap-k
                               (cdr amap)
                               (lambda (xs ys)
                                  (k (cons (car (car amap)) xs) (cons (cadr (car amap)) ys)))))))
         (void (lambda ()
                 (if #f #t #f)))
         (define? (lambda (s-exp)
                    (tagged-list? 'define s-exp)))
         (define-var? (lambda (s-exp)
                        (if (define? s-exp) (symbol? (cadr s-exp)) #f)))
         (define-fun? (lambda (s-exp)
                        (if (define? s-exp) (pair? (cadr s-exp)) #f)))
         (define->var (lambda (s-exp)
                        (if (define-var? s-exp)
                           (cadr s-exp)
                           (if (define-fun? s-exp)
                              (caadr s-exp)
                              (error "unknown define!")))))
         (define->exp (lambda (s-exp)
                        (if (<change> (define-var? s-exp) (not (define-var? s-exp)))
                           (caddr s-exp)
                           (if (define-fun? s-exp)
                              (cons three-d-lambda (cons (cdadr s-exp) (cddr s-exp)))
                              #f))))
         (if? (lambda (s-exp)
                (three-d-tagged-list? 'if s-exp)))
         (if-single? (lambda (s-exp)
                       (if (if? s-exp) (null? (cdddr s-exp)) #f)))
         (if->cond (lambda (s-exp)
                     (cadr s-exp)))
         (if->true (lambda (s-exp)
                     (caddr s-exp)))
         (if->false (lambda (s-exp)
                      (cadddr s-exp)))
         (quote? (lambda (s-exp)
                   (three-d-tagged-list? 'quote s-exp)))
         (quote->text (lambda (s-exp)
                        (cadr s-exp)))
         (lambda? (lambda (s-exp)
                    (three-d-tagged-list? 'lambda s-exp)))
         (lambda-multi? (lambda (s-exp)
                          (if (lambda? s-exp) (symbol? (cadr s-exp)) #f)))
         (lambda->formals (lambda (s-exp)
                            (cadr s-exp)))
         (lambda->body (lambda (s-exp)
                         (cddr s-exp)))
         (lambda->body-as-exp (lambda (s-exp)
                                (make-begin (cddr s-exp))))
         (begin? (lambda (s-exp)
                   (three-d-tagged-list? 'begin s-exp)))
         (begin->body (lambda (s-exp)
                        (cdr s-exp)))
         (make-begin (lambda (exps)
                       (if (singlet? exps)
                          (car exps)
                          (cons three-d-begin exps))))
         (app? (lambda (s-exp)
                 (pair? s-exp)))
         (app->fun (lambda (s-exp)
                     (car s-exp)))
         (app->args (lambda (s-exp)
                      (cdr s-exp)))
         (binding->var (lambda (binding)
                         (car binding)))
         (binding->exp (lambda (binding)
                         (cadr binding)))
         (letrec? (lambda (s-exp)
                    (three-d-tagged-list? 'letrec s-exp)))
         (letrec->bindings (lambda (s-exp)
                             (cadr s-exp)))
         (letrec->body (lambda (s-exp)
                         (<change>
                            (cddr s-exp)
                            ((lambda (x) x) (cddr s-exp)))))
         (letrec->body-as-exp (lambda (s-exp)
                                (make-begin (letrec->body s-exp))))
         (let? (lambda (s-exp)
                 (three-d-tagged-list? 'let s-exp)))
         (let->bindings (lambda (s-exp)
                          (cadr s-exp)))
         (let->body (lambda (s-exp)
                      (cddr s-exp)))
         (let->body-as-exp (lambda (s-exp)
                             (make-begin (let->body s-exp))))
         (let*? (lambda (s-exp)
                  (three-d-tagged-list? 'let* s-exp)))
         (let*->bindings (lambda (s-exp)
                           (<change>
                              ()
                              (cadr s-exp))
                           (<change>
                              ()
                              (cadr s-exp))
                           (cadr s-exp)))
         (let*->body (lambda (s-exp)
                       (cddr s-exp)))
         (let*->body-as-exp (lambda (s-exp)
                              (make-begin (let*->body s-exp))))
         (or? (lambda (s-exp)
                (three-d-tagged-list? 'or s-exp)))
         (or->exps (lambda (s-exp)
                     (cdr s-exp)))
         (make-or (lambda (exps)
                    (if (null? exps)
                       (<change>
                          #f
                          (if (singlet? exps) (car exps) (cons 'or exps)))
                       (<change>
                          (if (singlet? exps) (car exps) (cons 'or exps))
                          #f))))
         (and? (lambda (s-exp)
                 (three-d-tagged-list? 'and s-exp)))
         (and->exps (lambda (s-exp)
                      (<change>
                         (cdr s-exp)
                         ((lambda (x) x) (cdr s-exp)))))
         (make-and (lambda (exps)
                     (<change>
                        ()
                        (car exps))
                     (if (null? exps)
                        #t
                        (if (singlet? exps) (car exps) (cons 'and exps)))))
         (cond? (lambda (s-exp)
                  (three-d-tagged-list? 'cond s-exp)))
         (cond->clauses (lambda (s-exp)
                          (<change>
                             (cdr s-exp)
                             ((lambda (x) x) (cdr s-exp)))))
         (arrow-clause? (lambda (clause)
                          (if (pair? clause)
                             (if (pair? (cdr clause))
                                (eq? (cadr clause) '=>)
                                #f)
                             #f)))
         (else-clause? (lambda (clause)
                         (three-d-tagged-list? 'else clause)))
         (cond-clause->exp (lambda (clause)
                             (if (singlet? clause)
                                (car clause)
                                (if (else-clause? clause)
                                   (cadr clause)
                                   (if (arrow-clause? clause)
                                      (<change>
                                         (caddr clause)
                                         (make-begin (cdr clause)))
                                      (<change>
                                         (make-begin (cdr clause))
                                         (caddr clause)))))))
         (cond-clause->test (lambda (clause)
                              (if (singlet? clause)
                                 (car clause)
                                 (if (else-clause? clause)
                                    #t
                                    (if (arrow-clause? clause)
                                       (car clause)
                                       (car clause))))))
         (set!? (lambda (s-exp)
                  (<change>
                     (three-d-tagged-list? 'set! s-exp)
                     ((lambda (x) x) (three-d-tagged-list? 'set! s-exp)))))
         (set!->var (lambda (s-exp)
                      (cadr s-exp)))
         (set!->exp (lambda (s-exp)
                      (caddr s-exp)))
         (macro? (lambda (s-exp)
                   (<change>
                      ()
                      three-d-tagged-list?)
                   (three-d-tagged-list? 'macro s-exp)))
         (macro->proc (lambda (s-exp)
                        (cadr s-exp)))
         (syntax-primitive? (lambda (value)
                              (three-d-tagged-list? 'syntax-primitive value)))
         (syntax-primitive->eval (lambda (value)
                                   (cadr value)))
         (def->binding (lambda (def)
                         (list (define->var def) (define->exp def))))
         (body->letrec (lambda (decs)
                         (<change>
                            (partition-k
                               define?
                               decs
                               (lambda (defs exps)
                                  (if (null? defs)
                                     (make-begin exps)
                                     (let ((bindings (map def->binding defs)))
                                        (list three-d-letrec bindings (make-begin exps))))))
                            ((lambda (x) x)
                               (partition-k
                                  define?
                                  decs
                                  (lambda (defs exps)
                                     (<change>
                                        ()
                                        (make-begin exps))
                                     (if (null? defs)
                                        (make-begin exps)
                                        (let ((bindings (map def->binding defs)))
                                           (list three-d-letrec bindings (make-begin exps))))))))))
         (letrec->lets+sets (lambda (exp)
                              (if (not (letrec? exp))
                                 exp
                                 (let ((bindings (map
                                                   (lambda (binding)
                                                      (<change>
                                                         ()
                                                         (list (binding->var binding) #f))
                                                      (list (binding->var binding) #f))
                                                   (letrec->bindings exp)))
                                       (sets (map
                                               (lambda (binding)
                                                  (<change>
                                                     (list three-d-set! (binding->var binding) (binding->exp binding))
                                                     ((lambda (x) x) (list three-d-set! (binding->var binding) (binding->exp binding)))))
                                               (letrec->bindings exp))))
                                    (list three-d-let bindings (make-begin (append sets (letrec->body exp))))))))
         (cond->if (lambda (cond-exp)
                     (if (not (cond? cond-exp))
                        cond-exp
                        (cond-clauses->if (cond->clauses cond-exp)))))
         (cond-clauses->if (lambda (clauses)
                             (if (null? clauses)
                                (__toplevel_cons 'void ())
                                (let ((clause (car clauses)))
                                   (if (singlet? clause)
                                      (make-or (cons clause (cond-clauses->if (cdr clauses))))
                                      (if (<change> (else-clause? clause) (not (else-clause? clause)))
                                         (cond-clause->exp clause)
                                         (list
                                            three-d-if
                                            (cond-clause->test clause)
                                            (cond-clause->exp clause)
                                            (cond-clauses->if (cdr clauses)))))))))
         (and->if (lambda (exp)
                    (if (not (and? exp))
                       exp
                       (let ((exps (and->exps exp)))
                          (if (null? exps)
                             #t
                             (if (<change> (singlet? exps) (not (singlet? exps)))
                                (car exps)
                                (list three-d-if (car exps) (and->if (cons 'and (cdr exps))) #f)))))))
         (or->if (lambda (exp)
                   (if (<change> (not (or? exp)) (not (not (or? exp))))
                      exp
                      (let ((exps (or->exps exp)))
                         (if (null? exps)
                            #f
                            (if (singlet? exps)
                               (car exps)
                               (let (($tmp (gensym "or-tmp")))
                                  (list
                                     three-d-let
                                     (list (list $tmp (car exps)))
                                     (list three-d-if $tmp $tmp (or->if (cons three-d-or (cdr exps))))))))))))
         (let*->let (lambda (exp)
                      (if (not (let*? exp))
                         exp
                         (let*-bindings->let (let*->bindings exp) (let*->body exp)))))
         (let*-bindings->let (lambda (bindings body)
                               (if (singlet? bindings)
                                  (cons three-d-let (cons (list (car bindings)) body))
                                  (if (null? bindings)
                                     (<change>
                                        (make-begin body)
                                        (cons three-d-let (cons (list (car bindings)) (list (let*-bindings->let (cdr bindings) body)))))
                                     (<change>
                                        (cons three-d-let (cons (list (car bindings)) (list (let*-bindings->let (cdr bindings) body))))
                                        (make-begin body))))))
         (let->app (lambda (exp)
                     (if (not (let? exp))
                        exp
                        (unzip-amap-k
                           (let->bindings exp)
                           (lambda (vars exps)
                              (cons (cons three-d-lambda (cons vars (let->body exp))) exps))))))
         (eval (lambda (exp env)
                 (<change>
                    (if (symbol? exp)
                       (env-lookup env exp)
                       (if (number? exp)
                          exp
                          (if (boolean? exp)
                             exp
                             (if (string? exp)
                                exp
                                (if (procedure? exp)
                                   (exp)
                                   (if (app? exp)
                                      (perform-apply (eval (app->fun exp) env) exp env)
                                      #f))))))
                    ((lambda (x) x)
                       (if (symbol? exp)
                          (env-lookup env exp)
                          (if (number? exp)
                             exp
                             (if (<change> (boolean? exp) (not (boolean? exp)))
                                exp
                                (if (<change> (string? exp) (not (string? exp)))
                                   exp
                                   (if (procedure? exp)
                                      (exp)
                                      (if (app? exp)
                                         (<change>
                                            (perform-apply (eval (app->fun exp) env) exp env)
                                            #f)
                                         (<change>
                                            #f
                                            (perform-apply (eval (app->fun exp) env) exp env))))))))))))
         (eval-with (lambda (env)
                      (lambda (exp)
                         (eval exp env))))
         (eval* (lambda (exps env)
                  (map (eval-with env) exps)))
         (eval-quote (lambda (exp env)
                       (<change>
                          ()
                          (display quote->text))
                       (quote->text exp)))
         (eval-if (lambda (exp env)
                    (<change>
                       (if (if-single? exp)
                          (if (eval (if->cond exp) env)
                             (eval (if->true exp) env)
                             #f)
                          (if (eval (if->cond exp) env)
                             (eval (if->true exp) env)
                             (eval (if->false exp) env)))
                       ((lambda (x) x)
                          (if (if-single? exp)
                             (if (eval (if->cond exp) env)
                                (eval (if->true exp) env)
                                #f)
                             (if (eval (if->cond exp) env)
                                (eval (if->true exp) env)
                                (eval (if->false exp) env)))))))
         (eval-cond (lambda (exp env)
                      (eval (cond->if exp) env)))
         (eval-and (lambda (exp env)
                     (eval (and->if exp) env)))
         (eval-or (lambda (exp env)
                    (eval (or->if exp) env)))
         (eval-let (lambda (exp env)
                     (<change>
                        (eval (let->app exp) env)
                        ((lambda (x) x) (eval (let->app exp) env)))))
         (eval-let* (lambda (exp env)
                      (eval (let*->let exp) env)))
         (eval-letrec (lambda (exp env)
                        (eval (letrec->lets+sets exp) env)))
         (eval-begin (lambda (exp env)
                       (let ((simplified (body->letrec (begin->body exp))))
                          (if (begin? simplified)
                             (<change>
                                (car (reverse (eval* (begin->body exp) env)))
                                (eval simplified env))
                             (<change>
                                (eval simplified env)
                                (car (reverse (eval* (begin->body exp) env))))))))
         (eval-set! (lambda (exp env)
                      (env-set! env (set!->var exp) (eval (set!->exp exp) env))))
         (eval-lambda (lambda (exp env)
                        (let ((formals (lambda->formals exp)))
                           (<change>
                              (lambda args
                                 (if (symbol? formals)
                                    (eval (lambda->body-as-exp exp) (env-extend env formals args))
                                    (eval (lambda->body-as-exp exp) (env-extend* env formals args))))
                              ((lambda (x) x)
                                 (lambda args
                                    (if (symbol? formals)
                                       (eval (lambda->body-as-exp exp) (env-extend env formals args))
                                       (eval (lambda->body-as-exp exp) (env-extend* env formals args)))))))))
         (eval-macro (lambda (exp env)
                       (list 'macro (eval (macro->proc exp) env))))
         (env-lookup (lambda (env var)
                       (let ((value (env var #f 'unused)))
                          value)))
         (env-set! (lambda (env var value)
                     (env var #t value)))
         (env-extend (lambda (env var value)
                       (lambda (seek-var modify? value!)
                          (if (eq? var seek-var)
                             (if modify? (set! value value!) value)
                             (env seek-var modify? value!)))))
         (env-extend* (lambda (env vars values)
                        (if (pair? vars)
                           (env-extend* (env-extend env (car vars) (car values)) (cdr vars) (cdr values))
                           env)))
         (empty-env (lambda (var modify? value!)
                      (if modify?
                         (begin
                            (display "error: cannot modify undefined variable: ")
                            (display var)
                            (display " with ")
                            (display value!))
                         (begin
                            (display "error: cannot look up undefined variable: ")
                            (<change>
                               (display var)
                               ((lambda (x) x) (display var)))))
                      (<change>
                         (newline)
                         ((lambda (x) x) (newline)))
                      (error)))
         (initial-environment-amap (list
                                     (list 'apply apply)
                                     (list '+ +)
                                     (list 'not not)
                                     (list 'display display)
                                     (list 'newline newline)
                                     (list 'cons cons)
                                     (list 'car car)
                                     (list 'cdr cdr)
                                     (list 'cadr cadr)
                                     (list 'caadr caadr)
                                     (list 'cadar cadar)
                                     (list 'cddr cddr)
                                     (list 'cdddr cdddr)
                                     (list 'null? null?)
                                     (list 'pair? pair?)
                                     (list 'list? list?)
                                     (list 'number? number?)
                                     (list 'string? string?)
                                     (list 'symbol? symbol?)
                                     (list 'procedure? procedure?)
                                     (list 'eq? eq?)
                                     (list '= =)
                                     (list 'gensym gensym)
                                     (list 'void void)
                                     (list 'quote (list 'syntax-primitive eval-quote))
                                     (list 'if (list 'syntax-primitive eval-if))
                                     (list 'cond (list 'syntax-primitive eval-cond))
                                     (list 'and (list 'syntax-primitive eval-and))
                                     (list 'or (list 'syntax-primitive eval-or))
                                     (list 'let (list 'syntax-primitive eval-let))
                                     (list 'let* (list 'syntax-primitive eval-let*))
                                     (list 'letrec (list 'syntax-primitive eval-letrec))
                                     (list 'begin (list 'syntax-primitive eval-begin))
                                     (list 'set! (list 'syntax-primitive eval-set!))
                                     (list 'lambda (list 'syntax-primitive eval-lambda))
                                     (list 'macro (list 'syntax-primitive eval-macro))))
         (initial-environment (lambda ()
                                (unzip-amap-k
                                   initial-environment-amap
                                   (lambda (symbols values)
                                      (env-extend* empty-env symbols values)))))
         (initial (lambda (sym)
                    (env-lookup (initial-environment) sym)))
         (three-d (lambda (value)
                    (lambda ()
                       value)))
         (three-d-quote (three-d (initial 'quote)))
         (three-d-if (three-d (initial 'if)))
         (three-d-cond (three-d (initial 'cond)))
         (three-d-and (three-d (initial 'and)))
         (three-d-or (three-d (initial 'or)))
         (three-d-let (three-d (initial 'let)))
         (three-d-let* (three-d (initial 'let*)))
         (three-d-letrec (three-d (initial 'letrec)))
         (three-d-set! (three-d (initial 'set!)))
         (three-d-lambda (three-d (initial 'lambda)))
         (three-d-begin (three-d (initial 'begin)))
         (perform-apply (lambda (fun app-exp env)
                          (let ((args (app->args app-exp)))
                             (if (macro? fun)
                                (eval (apply (macro->proc fun) args) env)
                                (if (syntax-primitive? fun)
                                   ((syntax-primitive->eval fun) app-exp env)
                                   (let ((arg-values (eval* args env)))
                                      (apply fun arg-values))))))))
   (eval
      (__toplevel_cons
         (__toplevel_cons 'lambda (__toplevel_cons (__toplevel_cons 'x ()) (__toplevel_cons 'x ())))
         (__toplevel_cons 10 ()))
      (initial-environment)))