(define result '())
(define output (lambda (i) (set! result (cons i result))))

(define (make-ring n)
  (let ((last (cons 0 '())))
    (define (build-list n)
      (if (= n 0)
          last
          (cons n (build-list (- n 1)))))
    (let ((ring (build-list n)))
      (set-cdr! last ring)
      ring)))

(define (print-ring r)
  (define (aux l)
    (if (not (null? l))
        (if (eq? (cdr l) r)
            (begin (output " ")
                   (output (car l))
                   (output "..."))
            (begin (output " ")
                   (output (car l))
                   (aux (cdr l))))))
  (aux r)
  #t)

(define (copy-ring r)
  (define last '())
  (define (aux l)
    (cond ((eq? (cdr l) r)
           (set! last (cons (car l) '()))
           last)
          (else (cons (car l) (aux (cdr l))))))

  (let ((first (aux r)))
    (set-cdr! last first)
    first))

(define (right-rotate r)
  (define (iter l)
    (if (eq? (cdr l) r)
      l
      (iter (cdr l))))
  (iter r))

(define (Josephus r n)
  (define (remove-nth! l n)
    (if (<= n 2)
        (begin (set-cdr! l (cddr l))
               (cdr l))
        (remove-nth! (cdr l) (- n 1))))

  (define (iter l)
    (print-ring l)
    (if (eq? l (cdr l))
        (car l)
        (iter (remove-nth! l n))))

  (if (= n 1)
      (car (right-rotate r))
      (iter (copy-ring r))))

(define ring (make-ring 5))
(Josephus ring 5)
(print-ring ring)
(equal? result '("..." 0 " " 1 " " 2 " " 3 " " 4 " " 5 " " "..." 5 " " "..." 5 " " 3 " " "..." 3 " " 4 " " 5 " " "..." 3 " " 4 " " 5 " " 0 " " "..." 2 " " 3 " " 4 " " 5 " " 0 " " "..." 0 " " 1 " " 2 " " 3 " " 4 " " 5 " "))