(define T (int-top))
(define (append l m)
  (if (null? l)
      m
      (cons (car l) (append (cdr l) m))))
(define (filter f l)
  (if (pair? l)
      (let ((head (car l)))
        (if (f head)
            (cons head (filter f (cdr l)))
            (filter f (cdr l))))
      l))
(define InputSize (int-top))
(define Input (letrec ((loop (lambda (i acc)
                               (if (= i InputSize)
                                   acc
                                   (loop (+ i 1) (cons (int-top) acc))))))
                (loop 0 '())))

(define (qsort-seq data)
  (let ((data-length (length data)))
    (if (<= data-length 1)
        data
        (let* ((pivot (list-ref data (inexact->exact (round (/ data-length 2)))))
               (left-unsorted (filter (lambda (x) (< x pivot)) data))
               (left-sorted (qsort-seq left-unsorted))
               (equal-elements (filter (lambda (x) (= x pivot)) data))
               (right-unsorted (filter (lambda (x) (> x pivot)) data))
               (right-sorted (qsort-seq right-unsorted))
               (sorted (append left-sorted (append equal-elements right-sorted))))
          sorted))))

(define quicksort-actor
  (actor "quicksort-actor" (parent position-relative-to-parent result num-fragments)
           (sort (data)
                 (if (< (length data) T)
                     (let ((result (qsort-seq data)))
                       (if parent
                           (send parent result result position-relative-to-parent)
                           #t)
                       (terminate))
                     (let* ((data-length-half (inexact->exact (floor (/ (length data) 2))))
                            (pivot (list-ref data data-length-half))
                            (left-unsorted (filter (lambda (x) (< x pivot)) data))
                            (left-actor (create quicksort-actor a/self 'position-left '() 0))
                            (right-unsorted (filter (lambda (x) (> x pivot)) data))
                            (right-actor (create quicksort-actor a/self 'position-right '() 0)))
                       (send left-actor sort left-unsorted)
                       (send right-actor sort right-unsorted)
                       (become quicksort-actor parent position-relative-to-parent (filter (lambda (x) (= x pivot)) data) (+ num-fragments 1)))))
           (result (data position)
                   (let ((result2
                          (if (null? data)
                              result
                              (if (equal? position 'position-left)
                                  (append data result)
                                  (if (equal? position 'position-right)
                                      (append result data)
                                      result)))))
                     (if (= (+ num-fragments 1) 3)
                         (begin
                           (if parent
                               (send parent result result2 position-relative-to-parent)
                               #t)
                           (terminate))
                         (become quicksort-actor parent position-relative-to-parent result2 (+ num-fragments 1)))))))
(define root
  (create quicksort-actor #f 'position-initial '() 0))
(send root sort Input)
