; key not found: λ@363:18 [ε] (IncrementalGlobalStoreCY.scala:149)
(letrec ((list? (lambda (l)
                  (let ((__or_res (if (pair? l) (list? (cdr l)) #f)))
                    (if __or_res __or_res (null? l)))))
          (<= (lambda (x y)
                (assert (number? x))
                (let ((__or_res (< x y)))
                  (if __or_res
                    __or_res
                    (let ((__or_res (= x y)))
                      (if __or_res __or_res #f))))))
          (cddddr (lambda (x)
                    (cdr (cdr (cdr (cdr x))))))
          (newline (lambda ()
                     #f))
          (map (lambda (f l)
                 (assert (procedure? f))
                 (assert (list? l))
                 (if (null? l)
                   ()
                   (cons (f (car l)) (map f (cdr l))))))
          (cadr (lambda (x)
                  (car (cdr x))))
          (cddr (lambda (x)
                  (cdr (cdr x))))
          (list (lambda args
                  args))
          (cadddr (lambda (x)
                    (car (cdr (cdr (cdr x))))))
          (apply (lambda (proc args)
                   (assert (procedure? proc))
                   (assert (list? args))
                   (if (null? args)
                     (proc)
                     (if (null? (cdr args))
                       (proc (car args))
                       (if (null? (cddr args))
                         (proc (car args) (cadr args))
                         (if (null? (cdddr args))
                           (proc (car args) (cadr args) (caddr args))
                           (if (null? (cddddr args))
                             (proc (car args) (cadr args) (caddr args) (cadddr args))
                             (if (null? (cdr (cddddr args)))
                               (proc (car args) (cadr args) (caddr args) (cadddr args) (car (cddddr args)))
                               (if (null? (cddr (cddddr args)))
                                 (proc (car args) (cadr args) (caddr args) (cadddr args) (car (cddddr args)) (cadr (cddddr args)))
                                 (if (null? (cdddr (cddddr args)))
                                   (proc
                                     (car args)
                                     (cadr args)
                                     (caddr args)
                                     (cadddr args)
                                     (car (cddddr args))
                                     (cadr (cddddr args))
                                     (caddr (cddddr args)))
                                   (error "Unsupported call.")))))))))))
          (length (lambda (l)
                    (assert (list? l))
                    (letrec ((rec (lambda (l)
                                    (if (null? l) 0 (+ 1 (rec (cdr l)))))))
                      (rec l))))
          (caddr (lambda (x)
                   (car (cdr (cdr x)))))
          (cdddr (lambda (x)
                   (cdr (cdr (cdr x)))))
          (caadr (lambda (x)
                   (car (car (cdr x)))))
          (cdadr (lambda (x)
                   (cdr (car (cdr x)))))
          (__toplevel_cons cons)
          (for-each (lambda (f l)
                      (assert (procedure? f))
                      (assert (list? l))
                      (if (null? l)
                        #t
                        (if (pair? l)
                          (begin
                            (f (car l))
                            (for-each f (cdr l)))
                          #f))))
          (> (lambda (x y)
               (assert (number? x))
               (not (<= x y))))
          (not (lambda (x)
                 (if x #f #t)))
          (true #t)
          (false #f)
          (freeze? (<change>
                     #f
                     (lambda (exp)
                       (tagged-list? exp 'freeze))))
          (eval-freeze (<change>
                         #f
                         (lambda (exp env)
                           (let ((var (cadr exp)))
                             (freeze-variable! var env)
                             'done))))
          (eval (lambda (exp env)
                  (if (self-evaluating? exp)
                    exp
                    (if (variable? exp)
                      (lookup-variable-value exp env)
                      (if (quoted? exp)
                        (text-of-quotation exp)
                        (if (assignment? exp)
                          (eval-assignment exp env)
                          (if (definition? exp)
                            (eval-definition exp env)
                            (if (if? exp)
                              (eval-if exp env)
                              (if (lambda? exp)
                                (make-procedure (lambda-parameters exp) (lambda-body exp) env)
                                (if (begin? exp)
                                  (eval-sequence (begin-actions exp) env)
                                  (if (cond? exp)
                                    (eval (cond->if exp) env)
                                    (if (<change> #f (freeze? exp))
                                      (eval-freeze exp env)
                                      (if (application? exp)
                                        (apply-fun (eval (operator exp) env) (list-of-values (operands exp) env))
                                        (error "Unknown expression type -- EVAL" exp))))))))))))))
          (apply-fun (lambda (procedure arguments)
                       (if (primitive-procedure? procedure)
                         (apply-primitive-procedure procedure arguments)
                         (if (compound-procedure? procedure)
                           (eval-sequence
                             (procedure-body procedure)
                             (extend-environment (procedure-parameters procedure) arguments (procedure-environment procedure)))
                           (error "Unknown procedure type -- APPLY" procedure)))))
          (list-of-values (lambda (exps env)
                            (if (no-operands? exps)
                              ()
                              (cons (eval (first-operand exps) env) (list-of-values (rest-operands exps) env)))))
          (eval-assignment (lambda (exp env)
                             (set-variable-value! (assignment-variable exp) (eval (assignment-value exp) env) env)
                             'ok))
          (eval-definition (lambda (exp env)
                             (define-variable! (definition-variable exp) (eval (definition-value exp) env) env)
                             'ok))
          (true? (lambda (x)
                   (not (eq? x false))))
          (false? (lambda (x)
                    (eq? x false)))
          (eval-if (lambda (exp env)
                     (if (true? (eval (if-predicate exp) env))
                       (eval (if-consequent exp) env)
                       (eval (if-alternative exp) env))))
          (eval-sequence (lambda (exps env)
                           (if (last-exp? exps)
                             (eval (first-exp exps) env)
                             (begin
                               (eval (first-exp exps) env)
                               (eval-sequence (rest-exps exps) env)))))
          (self-evaluating? (lambda (exp)
                              (if (number? exp)
                                true
                                (if (string? exp) true false))))
          (tagged-list? (lambda (exp tag)
                          (if (pair? exp) (eq? (car exp) tag) false)))
          (quoted? (lambda (exp)
                     (tagged-list? exp 'quote)))
          (text-of-quotation (lambda (exp)
                               (cadr exp)))
          (variable? (lambda (exp)
                       (symbol? exp)))
          (assignment? (lambda (exp)
                         (tagged-list? exp 'set!)))
          (assignment-variable (lambda (exp)
                                 (cadr exp)))
          (assignment-value (lambda (exp)
                              (caddr exp)))
          (definition? (lambda (exp)
                         (tagged-list? exp 'define)))
          (definition-variable (lambda (exp)
                                 (if (symbol? (cadr exp)) (cadr exp) (caadr exp))))
          (definition-value (lambda (exp)
                              (if (symbol? (cadr exp))
                                (caddr exp)
                                (make-lambda (cdadr exp) (cddr exp)))))
          (if? (lambda (exp)
                 (tagged-list? exp 'if)))
          (if-predicate (lambda (exp)
                          (cadr exp)))
          (if-consequent (lambda (exp)
                           (caddr exp)))
          (if-alternative (lambda (exp)
                            (if (not (null? (cdddr exp)))
                              (cadddr exp)
                              'false)))
          (make-if (lambda (predicate consequent alternative)
                     (list 'if predicate consequent alternative)))
          (lambda? (lambda (exp)
                     (tagged-list? exp 'lambda)))
          (lambda-parameters (lambda (exp)
                               (cadr exp)))
          (lambda-body (lambda (exp)
                         (cddr exp)))
          (make-lambda (lambda (parameters body)
                         (cons 'lambda (cons parameters body))))
          (cond? (lambda (exp)
                   (tagged-list? exp 'cond)))
          (cond-clauses (lambda (exp)
                          (cdr exp)))
          (cond-else-clause? (lambda (clause)
                               (eq? (cond-predicate clause) 'else)))
          (cond-predicate (lambda (clause)
                            (car clause)))
          (cond-actions (lambda (clause)
                          (cdr clause)))
          (cond->if (lambda (exp)
                      (expand-clauses (cond-clauses exp))))
          (expand-clauses (lambda (clauses)
                            (if (null? clauses)
                              'false
                              (let ((first (car clauses))
                                     (rest (cdr clauses)))
                                (if (cond-else-clause? first)
                                  (if (null? rest)
                                    (sequence->exp (cond-actions first))
                                    (error "ELSE clause isn't last -- COND->IF" clauses))
                                  (make-if (cond-predicate first) (sequence->exp (cond-actions first)) (expand-clauses rest)))))))
          (begin? (lambda (exp)
                    (tagged-list? exp 'begin)))
          (begin-actions (lambda (exp)
                           (cdr exp)))
          (last-exp? (lambda (seq)
                       (null? (cdr seq))))
          (first-exp (lambda (seq)
                       (car seq)))
          (rest-exps (lambda (seq)
                       (cdr seq)))
          (sequence->exp (lambda (seq)
                           (if (null? seq)
                             seq
                             (if (last-exp? seq)
                               (first-exp seq)
                               (make-begin seq)))))
          (make-begin (lambda (seq)
                        (cons 'begin seq)))
          (application? (lambda (exp)
                          (pair? exp)))
          (operator (lambda (exp)
                      (car exp)))
          (operands (lambda (exp)
                      (cdr exp)))
          (no-operands? (lambda (ops)
                          (null? ops)))
          (first-operand (lambda (ops)
                           (car ops)))
          (rest-operands (lambda (ops)
                           (cdr ops)))
          (make-procedure (lambda (parameters body env)
                            (list 'procedure parameters body env)))
          (compound-procedure? (lambda (p)
                                 (tagged-list? p 'procedure)))
          (procedure-parameters (lambda (p)
                                  (cadr p)))
          (procedure-body (lambda (p)
                            (caddr p)))
          (procedure-environment (lambda (p)
                                   (cadddr p)))
          (enclosing-environment (lambda (env)
                                   (cdr env)))
          (first-frame (lambda (env)
                         (car env)))
          (the-empty-environment ())
          (extend-environment (lambda (vars vals base-env)
                                (if (= (length vars) (length vals))
                                  (cons (make-frame vars vals) base-env)
                                  (if (< (length vars) (length vals))
                                    (error "Too many arguments supplied" vars vals)
                                    (error "Too few arguments supplied" vars vals)))))
          (make-frame (lambda (variables values)
                        (<change>
                          (cons variables values)
                          (vector variables values (map (lambda (any) #f) values)))))
          (frame-variables (lambda (frame)
                             (<change>
                               (car frame)
                               (vector-ref frame 0))))
          (frame-values (lambda (frame)
                          (<change>
                            (cdr frame)
                            (vector-ref frame 1))))
          (frame-frozen?s (<change>
                            #f
                            (lambda (frame)
                              (vector-ref frame 2))))
          (add-binding-to-frame! (lambda (var val frame)
                                   (<change>
                                     (begin
                                       (set-car! frame (cons var (car frame)))
                                       (set-cdr! frame (cons val (cdr frame))))
                                     (begin
                                       (vector-set! frame 0 (cons var (frame-variables frame)))
                                       (vector-set! frame 1 (cons val (frame-values frame)))
                                       (vector-set! frame 2 (cons #f (frame-frozen?s frame)))))))
          (lookup-variable-value (lambda (var env)
                                   (letrec ((env-loop (lambda (env)
                                                        (letrec ((scan (lambda (vars vals)
                                                                         (if (null? vars)
                                                                           (env-loop (enclosing-environment env))
                                                                           (if (eq? var (car vars))
                                                                             (car vals)
                                                                             (scan (cdr vars) (cdr vals)))))))
                                                          (if (eq? env the-empty-environment)
                                                            (error "Unbound variable" var)
                                                            (let ((frame (first-frame env)))
                                                              (scan (frame-variables frame) (frame-values frame))))))))
                                     (env-loop env))))
          (set-variable-value! (lambda (var val env)
                                 (letrec ((env-loop (lambda (env)
                                                      (letrec ((scan (<change>
                                                                       (lambda (vars vals)
                                                                         (if (null? vars)
                                                                           (env-loop (enclosing-environment env))
                                                                           (if (eq? var (car vars))
                                                                             (set-car! vals val)
                                                                             (scan (cdr vars) (cdr vals)))))
                                                                       (lambda (vars vals frozen?s)
                                                                         (if (null? vars)
                                                                           (env-loop (enclosing-environment env))
                                                                           (if (eq? var (car vars))
                                                                             (if (car frozen?s)
                                                                               (error "Trying to assign a frozen variable -- SET!" var)
                                                                               (set-car! vals val))
                                                                             (scan (cdr vars) (cdr vals) (cdr frozen?s))))))))
                                                        (if (eq? env the-empty-environment)
                                                          (error "Unbound variable -- SET!" var)
                                                          (let ((frame (first-frame env)))
                                                            (<change>
                                                              (scan (frame-variables frame) (frame-values frame))
                                                              (scan (frame-variables frame) (frame-values frame) (frame-frozen?s frame)))))))))
                                   (env-loop env))))
          (freeze-variable! (<change>
                              #f
                              (lambda (var env)
                                (letrec ((env-loop (lambda (env)
                                                     (letrec ((scan (lambda (vars frozen?s)
                                                                      (if (null? vars)
                                                                        (env-loop (enclosing-environment env))
                                                                        (if (eq? var (car vars))
                                                                          (set-car! frozen?s #t)
                                                                          (scan (cdr vars) (cdr frozen?s)))))))
                                                       (if (eq? env the-empty-environment)
                                                         (error "Unbound variable -- FREEZE!" var)
                                                         (let ((frame (first-frame env)))
                                                           (scan (frame-variables frame) (frame-frozen?s frame))))))))
                                  (env-loop env)))))
          (define-variable! (lambda (var val env)
                              (let ((frame (first-frame env)))
                                (letrec ((scan (lambda (vars vals)
                                                 (if (null? vars)
                                                   (add-binding-to-frame! var val frame)
                                                   (if (eq? var (car vars))
                                                     (set-car! vals val)
                                                     (scan (cdr vars) (cdr vals)))))))
                                  (scan (frame-variables frame) (frame-values frame))))))
          (setup-environment (lambda ()
                               (let ((initial-env (extend-environment
                                                    (primitive-procedure-names)
                                                    (primitive-procedure-objects)
                                                    the-empty-environment)))
                                 (define-variable! 'true true initial-env)
                                 (define-variable! 'false false initial-env)
                                 initial-env)))
          (primitive-procedures (list
                                  (list 'car car)
                                  (list 'cdr cdr)
                                  (list 'cons cons)
                                  (list 'null? null?)
                                  (list '+ +)
                                  (list '* *)
                                  (list '/ /)
                                  (list '= =)
                                  (list '- -)
                                  (list '< <)
                                  (list '> >)
                                  (list 'display display)
                                  (list 'list list)))
          (primitive-procedure-names (lambda ()
                                       (map car primitive-procedures)))
          (primitive-procedure-objects (lambda ()
                                         (map (lambda (proc) (list 'primitive (cadr proc))) primitive-procedures)))
          (the-global-environment (setup-environment))
          (input (__toplevel_cons
                   (__toplevel_cons 'define (__toplevel_cons 'a (__toplevel_cons 2 ())))
                   (__toplevel_cons
                     (__toplevel_cons 'define (__toplevel_cons 'b (__toplevel_cons 3 ())))
                     (__toplevel_cons
                       (__toplevel_cons 'define (__toplevel_cons 'c (__toplevel_cons 4 ())))
                       (__toplevel_cons
                         (__toplevel_cons 'freeze (__toplevel_cons 'a ()))
                         (__toplevel_cons
                           (__toplevel_cons 'freeze (__toplevel_cons 'c ()))
                           (__toplevel_cons
                             (__toplevel_cons
                               'define
                               (__toplevel_cons
                                 (__toplevel_cons 'set-fn! (__toplevel_cons 'x (__toplevel_cons 'y ())))
                                 (__toplevel_cons
                                   (__toplevel_cons 'define (__toplevel_cons 'a (__toplevel_cons 0 ())))
                                   (__toplevel_cons
                                     (__toplevel_cons 'set! (__toplevel_cons 'a (__toplevel_cons 'x ())))
                                     (__toplevel_cons
                                       (__toplevel_cons 'set! (__toplevel_cons 'b (__toplevel_cons 'y ())))
                                       (__toplevel_cons
                                         (__toplevel_cons 'list (__toplevel_cons 'a (__toplevel_cons 'b (__toplevel_cons 'c ()))))
                                         ()))))))
                             (__toplevel_cons
                               (__toplevel_cons 'set-fn! (__toplevel_cons 0 (__toplevel_cons 1 ())))
                               (__toplevel_cons
                                 (__toplevel_cons
                                   'begin
                                   (__toplevel_cons
                                     (__toplevel_cons 'freeze (__toplevel_cons 'b ()))
                                     (__toplevel_cons (__toplevel_cons 'set-fn! (__toplevel_cons 5 (__toplevel_cons 6 ()))) ())))
                                 ())))))))))
          (_0 (for-each
                (lambda (in)
                  (let ((output (eval in the-global-environment)))
                    (announce-output output-prompt)
                    (user-print output)))
                input)))
  _0)